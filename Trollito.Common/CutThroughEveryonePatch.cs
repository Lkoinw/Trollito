using HarmonyLib;
using System;
using System.Reflection;
using System.Threading.Tasks;
using TaleWorlds.Engine;
using TaleWorlds.Library;
using TaleWorlds.MountAndBlade;
using TaleWorlds.MountAndBlade.AutoGenerated;

namespace Trollito.Common
{
    /// <summary>
    /// Credits to Xorberax for original Cut Through Everyone mod
    /// </summary>
    public static class CutThroughEveryonePatch
    {
        private static readonly Harmony Harmony = new Harmony(nameof(CutThroughEveryonePatch));

        private static bool _patched;
        private static MethodInfo setPositionMethod;
        private static object scriptingInterface;

        public static bool Patch()
        {
            try
            {
                // Get the ScriptingInterfaceOfIMBAgent type by its full name
                string typeName = "ManagedCallbacks.ScriptingInterfaceOfIMBAgent";
                Type scriptingInterfaceType = Type.GetType(typeName);
                // Get the MethodInfo for the SetPosition method
                setPositionMethod = scriptingInterfaceType.GetMethod("SetPosition");
                // Create an instance of the ScriptingInterfaceOfIMBAgent type
                scriptingInterface = Activator.CreateInstance(scriptingInterfaceType);

                if (_patched)
                    return false;

                _patched = true;

                Harmony.Patch(
                    AccessTools.Method(typeof(Mission), "DecideWeaponCollisionReaction"),
                    postfix: new HarmonyMethod(typeof(CutThroughEveryonePatch), nameof(DecideWeaponCollisionReactionPostfix))
                );

                Harmony.Patch(
                    AccessTools.Method(typeof(Mission), "MeleeHitCallback"),
                    postfix: new HarmonyMethod(typeof(CutThroughEveryonePatch), nameof(MeleeHitCallbackPostfix))
                );

                return true;
            }
            catch (Exception e)
            {
                Debug.Print("Error in CutThroughEveryonePatch: " + e.ToString(), 0, Debug.DebugColor.Red);
                return false;
            }
        }

        public static void DecideWeaponCollisionReactionPostfix(ref AttackCollisionData collisionData, Agent attacker, Agent defender, ref MeleeCollisionReaction colReaction)
        {
            bool flag = attacker.Name.ToLower().Contains("troll");
            if (flag)
            {
                colReaction = MeleeCollisionReaction.SlicedThrough;
            }
        }

        public static void MeleeHitCallbackPostfix(ref AttackCollisionData collisionData, Agent attacker, Agent victim, GameEntity realHitEntity, ref float inOutMomentumRemaining, ref MeleeCollisionReaction colReaction, CrushThroughState crushThroughState, Vec3 blowDir, Vec3 swingDir, ref HitParticleResultData hitParticleResultData, bool crushedThroughWithoutAgentCollision)
        {
            int num = collisionData.InflictedDamage + collisionData.AbsorbedByArmor;
            bool flag = num >= 1 && attacker.Name.ToLower().Contains("troll");
            if (flag)
            {
                float num2 = (float)collisionData.InflictedDamage / (float)num;
                float pushDistance = 8f * num2; // Adjust the push distance as needed
                float projectionDuration = 0.4f * num2; // Adjust the duration of the projection effect

                // Calculate the push direction based on the blow direction
                Vec3 pushDirection = swingDir;

                Vec3 pushVector = pushDirection * pushDistance + Vec3.Up * 100f;
                
                PerformProjection2(victim, pushVector, projectionDuration);

                // Remaining momentum
                inOutMomentumRemaining = num2 * 0.8f;
            }
        }

        public static async Task PerformProjection(Agent victim, Vec3 projectionVector, float duration)
        {
            float startTime = Mission.Current.CurrentTime;
            Vec3 originalPosition = victim.Position;
            Vec3 targetPosition = originalPosition + projectionVector;

            while (Mission.Current.CurrentTime - startTime < duration)
            {
                float t = (Mission.Current.CurrentTime - startTime) / duration;
                Vec3 newPosition = Vec3.Lerp(originalPosition, targetPosition, t);

                victim.TeleportToPosition(newPosition);

                await Task.Yield();
            }

            // Ensure the victim is at the final projected position
            victim.TeleportToPosition(targetPosition);
        }

        public static async Task PerformProjection2(Agent victim, Vec3 projectionVector, float duration)
        {
            float startTime = Mission.Current.CurrentTime;
            Vec3 originalPosition = victim.Position;
            Vec3 targetPosition = originalPosition + projectionVector;

            while (Mission.Current.CurrentTime - startTime < duration)
            {
                float t = (Mission.Current.CurrentTime - startTime) / duration;
                Vec3 newPosition = Vec3.Lerp(originalPosition, targetPosition, t);
                
                // Invoke the SetPosition method
                setPositionMethod.Invoke(scriptingInterface, new object[] { victim, newPosition });

                //victim.TeleportToPosition(newPosition);

                await Task.Yield();
            }

            // Ensure the victim is at the final projected position
            victim.TeleportToPosition(targetPosition);
        }        
    }
}
